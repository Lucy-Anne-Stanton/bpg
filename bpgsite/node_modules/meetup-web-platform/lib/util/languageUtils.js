'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.checkLanguageRedirect = exports.getLanguage = exports.getBrowserLang = exports.getUrlLang = exports.getCookieLang = exports.LANG_DEFAULT = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _qs = require('qs');

var _qs2 = _interopRequireDefault(_qs);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _accepts = require('accepts');

var _accepts2 = _interopRequireDefault(_accepts);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var LANG_DEFAULT = exports.LANG_DEFAULT = 'en-US';

var getCookieLang = exports.getCookieLang = function getCookieLang(request, supportedLangs) {
	var cookie = request.state.MEETUP_LANGUAGE;
	if (!cookie) {
		return;
	}

	var _querystring$parse = _qs2.default.parse(cookie),
	    language = _querystring$parse.language,
	    country = _querystring$parse.country;

	var cookieLang = language + '-' + country;
	return supportedLangs.includes(cookieLang) && cookieLang;
};

var getUrlLang = exports.getUrlLang = function getUrlLang(request, supportedLangs) {
	var urlLang = request.url.path.split('/')[1];
	return supportedLangs.includes(urlLang) && urlLang;
};

/**
 * @param {Object} request Hapi request from browser
 * @param {Array} supportedLangs a _sorted_ list of supported langs, with
 *   preferred languages first
 * @return {String|Boolean} language code
 */
var getBrowserLang = exports.getBrowserLang = function getBrowserLang(request, supportedLangs) {
	return (0, _accepts2.default)(request).language(supportedLangs);
};

var getLanguage = exports.getLanguage = function getLanguage(request, supportedLangs) {
	var defaultLang = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : LANG_DEFAULT;

	// return the first language hit in the order of preference
	supportedLangs.sort(function (l) {
		return l !== defaultLang;
	});
	return getCookieLang(request, supportedLangs) || getUrlLang(request, supportedLangs) || getBrowserLang(request, supportedLangs) || defaultLang;
};

var makeRedirect = function makeRedirect(reply, originalUrl) {
	return function (redirectPathname) {
		return reply.redirect(_url2.default.format(_extends({}, originalUrl, { pathname: redirectPathname })));
	};
};

var checkLanguageRedirect = exports.checkLanguageRedirect = function checkLanguageRedirect(request, reply, requestLanguage, supportedLangs) {
	var defaultLang = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : LANG_DEFAULT;

	// ensure defaultLang is first in supportedLangs
	supportedLangs.sort(function (l) {
		return l !== defaultLang;
	});
	var originalPath = request.url.pathname;
	var firstPathComponent = originalPath.split('/')[1];
	var redirect = makeRedirect(reply, request.url);
	if (requestLanguage === defaultLang) {
		// ensure that we are serving from un-prefixed URL
		if (supportedLangs.includes(firstPathComponent)) {
			request.log(['info'], 'Incorrect lang path prefix (' + firstPathComponent + '), redirecting');
			return redirect(originalPath.replace('/' + firstPathComponent, ''));
		}
	} else if (requestLanguage !== firstPathComponent) {
		// must redirect either by correcting the lang prefix or inserting it
		var cleanOriginal = originalPath.replace(new RegExp('^/(' + supportedLangs.join('|') + ')/'), '/');
		var newPathname = '/' + requestLanguage + cleanOriginal;
		return redirect(newPathname);
	}
	return null;
};