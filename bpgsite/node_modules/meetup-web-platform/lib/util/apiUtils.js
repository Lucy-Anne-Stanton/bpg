'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.makeApiRequest$ = exports.injectResponseCookies = exports.parseLoginAuth = exports.logApiResponse = exports.makeExternalApiRequest = exports.makeMockRequest = exports.apiResponseDuotoneSetter = exports.groupDuotoneSetter = exports.apiResponseToQueryResponse = exports.buildRequestArgs = exports.parseApiResponse = exports.parseApiValue = exports.errorResponse$ = exports.parseMetaHeaders = exports.createCookieJar = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.getAuthHeaders = getAuthHeaders;
exports.parseRequestHeaders = parseRequestHeaders;
exports.parseRequestQueries = parseRequestQueries;
exports.parseRequest = parseRequest;

var _qs = require('qs');

var _qs2 = _interopRequireDefault(_qs);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _uuid = require('uuid');

var _uuid2 = _interopRequireDefault(_uuid);

var _request = require('request');

var _request2 = _interopRequireDefault(_request);

var _joi = require('joi');

var _joi2 = _interopRequireDefault(_joi);

var _rxjs = require('rxjs');

var _rxjs2 = _interopRequireDefault(_rxjs);

var _authUtils = require('./authUtils');

var _stringUtils = require('./stringUtils');

var _validation = require('./validation');

var _duotone = require('./duotone');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var MOCK_RESPONSE_OK = { // minimal representation of http.IncomingMessage
	statusCode: 200,
	statusMessage: 'OK',
	headers: {
		'x-meetup-request-id': 'mock request'
	},
	request: {
		uri: {}
	}
};

/**
 * In order to receive cookies from `externalRequest` requests, this function
 * provides a cookie jar that is specific to the request.
 *
 * The `requestUrl` is used to determine whether a cookie jar is needed
 *
 * https://github.com/request/request#examples
 *
 * @param {String} requestUrl the URL that will be used in the external request
 * @return {Object} a cookie jar compatible with the npm request `jar` API
 */
var createCookieJar = exports.createCookieJar = function createCookieJar(requestUrl) {
	var parsedUrl = _url2.default.parse(requestUrl);
	if (parsedUrl.pathname === '/sessions') {
		return _request2.default.jar(); // create request/url-specific cookie jar
	}
	return null;
};

var X_HEADERS = ['x-total-count'];

var parseMetaHeaders = exports.parseMetaHeaders = function parseMetaHeaders(headers) {
	var meetupHeaders = Object.keys(headers).filter(function (h) {
		return h.startsWith('x-meetup-');
	}).reduce(function (meta, h) {
		var key = (0, _stringUtils.toCamelCase)(h.replace('x-meetup-', ''));
		meta[key] = headers[h];
		return meta;
	}, {});

	// special case handling for flags
	if (meetupHeaders.flags) {
		meetupHeaders.flags = _qs2.default.parse(meetupHeaders.flags, {
			delimiter: ',',
			decoder: _stringUtils.coerceBool
		});
	}

	var xHeaders = X_HEADERS.reduce(function (meta, h) {
		var key = (0, _stringUtils.toCamelCase)(h.replace('x-', ''));
		if (h in headers) {
			meta[key] = headers[h];
		}
		return meta;
	}, {});

	return _extends({}, meetupHeaders, xHeaders);
};

/**
 * Accept an Error and return an object that will be used in place of the
 * expected API return value
 */
function formatApiError(err) {
	return {
		error: err.message
	};
}

var errorResponse$ = exports.errorResponse$ = function errorResponse$(requestUrl) {
	return function (err) {
		return _rxjs2.default.Observable.of({
			value: formatApiError(err),
			meta: {
				endpoint: _url2.default.parse(requestUrl).pathname
			}
		});
	};
};

var parseApiValue = exports.parseApiValue = function parseApiValue(_ref) {
	var _ref2 = _slicedToArray(_ref, 2),
	    response = _ref2[0],
	    body = _ref2[1];

	// treat non-success HTTP code as an error
	if (response.statusCode < 200 || response.statusCode > 299) {
		return formatApiError(new Error(response.statusMessage));
	}
	try {
		if (response.statusCode === 204) {
			// NoContent response type
			return null;
		}

		var value = JSON.parse(body);
		if (value && value.problem) {
			return formatApiError(new Error('API problem: ' + value.problem + ': ' + value.details));
		}
		return value;
	} catch (err) {
		return formatApiError(err);
	}
};

/**
 *
 * mostly error handling - any case where the API does not satisfy the
 * "api response" formatting requirement: plain object containing the requested
 * values
 *
 * This utility is specific to the response format of the API being consumed
 * @param {Array} the callback args for npm request - [response, body], where
 * `response` is an `Http.IncomingMessage` and `body` is the body text of the
 * response.
 * @return responseObj the JSON-parsed text, possibly with error info
 */
var parseApiResponse = exports.parseApiResponse = function parseApiResponse(requestUrl) {
	return function (_ref3) {
		var _ref4 = _slicedToArray(_ref3, 2),
		    response = _ref4[0],
		    body = _ref4[1];

		var meta = _extends({}, parseMetaHeaders(response.headers), {
			endpoint: _url2.default.parse(requestUrl).pathname
		});

		return {
			value: parseApiValue([response, body]),
			meta: meta
		};
	};
};

/**
 * Transform each query into the arguments needed for a `request` call.
 *
 * Some request options are constant for all queries, and these are curried into
 * a function that can be called with a single query as part of the request
 * stream
 *
 * @see {@link https://www.npmjs.com/package/request}
 *
 * @param {Object} externalRequestOpts request options that will be applied to
 *   every query request
 * @param {Object} query { endpoint, params, flags }
 *   call)
 * @return {Object} externalRequestOptsQuery argument for the call to
 *   `externalRequest` for the query
 */
var buildRequestArgs = exports.buildRequestArgs = function buildRequestArgs(externalRequestOpts) {
	return function (_ref5) {
		var endpoint = _ref5.endpoint,
		    params = _ref5.params,
		    flags = _ref5.flags;


		// cheap, brute-force object clone, acceptable for serializable object
		var externalRequestOptsQuery = JSON.parse(JSON.stringify(externalRequestOpts));

		externalRequestOptsQuery.url = encodeURI('/' + endpoint);
		externalRequestOptsQuery.jar = createCookieJar(externalRequestOptsQuery.url);

		if (flags) {
			externalRequestOptsQuery.headers['X-Meetup-Request-Flags'] = flags.join(',');
		}

		var dataParams = _qs2.default.stringify(params);

		switch (externalRequestOptsQuery.method) {
			case 'get':
			case 'delete':
				externalRequestOptsQuery.url += '?' + dataParams;
				externalRequestOptsQuery.headers['X-Meta-Photo-Host'] = 'secure';
				break;
			case 'post':
				externalRequestOptsQuery.body = dataParams;
				externalRequestOptsQuery.headers['content-type'] = 'application/x-www-form-urlencoded';
				break;
		}

		// production logs will automatically be JSON-parsed in Stackdriver
		console.log(JSON.stringify({
			type: 'External request headers',
			payload: externalRequestOptsQuery.headers
		}));

		return externalRequestOptsQuery;
	};
};

/**
 * Format apiResponse to match expected state structure
 *
 * @param {Object} apiResponse JSON-parsed api response data
 */
var apiResponseToQueryResponse = exports.apiResponseToQueryResponse = function apiResponseToQueryResponse(query) {
	return function (_ref6) {
		var value = _ref6.value,
		    meta = _ref6.meta;
		return _defineProperty({}, query.ref, {
			type: query.type,
			value: value,
			meta: meta
		});
	};
};

function getAuthHeaders(_ref8) {
	var state = _ref8.state;

	// internal server requests may set non-encoded token cookie __internal_oauth_token
	var oauth_token = state.oauth_token || state.__internal_oauth_token;
	if (!state.MEETUP_MEMBER && oauth_token) {
		return {
			authorization: 'Bearer ' + oauth_token
		};
	}
	var cookies = _extends({}, state);
	var csrf = _uuid2.default.v4();
	cookies.MEETUP_CSRF = csrf;
	cookies.MEETUP_CSRF_DEV = csrf;
	var cookie = Object.keys(cookies).map(function (name) {
		return name + '=' + cookies[name];
	}).join('; ');

	return {
		cookie: cookie,
		'csrf-token': csrf
	};
}

function parseRequestHeaders(request) {
	var externalRequestHeaders = _extends({}, request.headers, getAuthHeaders(request));

	delete externalRequestHeaders['host']; // let app server set 'host'
	delete externalRequestHeaders['accept-encoding']; // let app server set 'accept'
	delete externalRequestHeaders['content-length']; // original request content-length is irrelevant

	// cloudflare headers we don't want to pass on
	delete externalRequestHeaders['cf-ray'];
	delete externalRequestHeaders['cf-ipcountry'];
	delete externalRequestHeaders['cf-visitor'];
	delete externalRequestHeaders['cf-connecting-ip'];

	return externalRequestHeaders;
}

function parseRequestQueries(request) {
	var method = request.method,
	    payload = request.payload,
	    query = request.query;

	var queriesJSON = method === 'post' ? payload.queries : query.queries;
	var validatedQueries = _joi2.default.validate(JSON.parse(queriesJSON), _joi2.default.array().items(_validation.querySchema));
	if (validatedQueries.error) {
		throw validatedQueries.error;
	}
	return validatedQueries.value;
}

/**
 * Parse request for queries and request options
 * @return {Object} { queries, externalRequestOpts }
 */
function parseRequest(request, baseUrl) {
	return {
		externalRequestOpts: {
			baseUrl: baseUrl,
			method: request.method,
			headers: parseRequestHeaders(request), // make a copy to be immutable
			mode: 'no-cors',
			time: true, // time the request for logging
			agentOptions: {
				rejectUnauthorized: baseUrl.indexOf('.dev') === -1
			}
		},
		queries: parseRequestQueries(request)
	};
}

/**
 * From a provided set of signed duotone URLs, create a function that injects
 * the full duotone URL into a group object with the key `duotoneUrl`.
 *
 * @param {Object} duotoneUrls map of `[duotoneRef]: url template root`
 * @param {Object} group group object from API
 * @return {Object} the mutated group object
 */
var groupDuotoneSetter = exports.groupDuotoneSetter = function groupDuotoneSetter(duotoneUrls) {
	return function (group) {
		var photo = group.key_photo || group.group_photo || {};
		var duotoneKey = group.photo_gradient && (0, _duotone.duotoneRef)(group.photo_gradient.light_color, group.photo_gradient.dark_color);
		var duotoneUrlRoot = duotoneKey && duotoneUrls[duotoneKey];
		if (duotoneUrlRoot && photo.id) {
			group.duotoneUrl = duotoneUrlRoot + '/' + photo.id + '.jpeg';
		}
		return group;
	};
};

/**
 * From a provided set of signed duotoneUrls, create a function that injects
 * the full duotone URL into an query response containing objects that support
 * duotoned images (anything containing group or event objects
 *
 * @param {Object} duotoneUrls map of `[duotoneRef]: url template root`
 * @param {Object} queryResponse { type: <type>, value: <API object> }
 * @return {Object} the modified queryResponse
 */
var apiResponseDuotoneSetter = exports.apiResponseDuotoneSetter = function apiResponseDuotoneSetter(duotoneUrls) {
	var setGroupDuotone = groupDuotoneSetter(duotoneUrls);
	return function (queryResponse) {
		// inject duotone URLs into any group query response
		Object.keys(queryResponse).forEach(function (key) {
			var _queryResponse$key = queryResponse[key],
			    type = _queryResponse$key.type,
			    value = _queryResponse$key.value;

			if (!value || value.error) {
				return;
			}
			var groups = void 0;
			switch (type) {
				case 'group':
					groups = value instanceof Array ? value : [value];
					groups.forEach(setGroupDuotone);
					break;
				case 'home':
					(value.rows || []).map(function (_ref9) {
						var items = _ref9.items;
						return items;
					}).forEach(function (items) {
						return items.filter(function (_ref10) {
							var type = _ref10.type;
							return type === 'group';
						}).forEach(function (_ref11) {
							var group = _ref11.group;
							return setGroupDuotone(group);
						});
					});
					break;
			}
		});
		return queryResponse;
	};
};

/**
 * Fake an API request and directly return the stringified mockResponse
 */
var makeMockRequest = exports.makeMockRequest = function makeMockRequest(mockResponse) {
	return function (requestOpts) {
		return _rxjs2.default.Observable.of([MOCK_RESPONSE_OK, JSON.stringify(mockResponse)]).do(function () {
			return console.log('MOCKING response to ' + requestOpts.url);
		});
	};
};

var externalRequest$ = _rxjs2.default.Observable.bindNodeCallback(_request2.default);
/**
 * Make a real external API request, return response body string
 */
var makeExternalApiRequest = exports.makeExternalApiRequest = function makeExternalApiRequest(request, API_TIMEOUT) {
	return function (requestOpts) {
		return externalRequest$(requestOpts).timeout(API_TIMEOUT).map(function (_ref12) {
			var _ref13 = _slicedToArray(_ref12, 2),
			    response = _ref13[0],
			    body = _ref13[1];

			return [response, body, requestOpts.jar];
		});
	};
};

var logApiResponse = exports.logApiResponse = function logApiResponse(_ref14) {
	var _ref15 = _slicedToArray(_ref14, 2),
	    response = _ref15[0],
	    body = _ref15[1];

	var _response$request = response.request,
	    _response$request$uri = _response$request.uri,
	    query = _response$request$uri.query,
	    pathname = _response$request$uri.pathname,
	    method = _response$request.method;


	var responseLog = {
		request: {
			query: (query || '').split('&').reduce(function (acc, keyval) {
				var _keyval$split = keyval.split('='),
				    _keyval$split2 = _slicedToArray(_keyval$split, 2),
				    key = _keyval$split2[0],
				    val = _keyval$split2[1];

				acc[key] = val;
				return acc;
			}, {}),
			pathname: pathname,
			method: method
		},
		response: {
			elapsedTime: response.elapsedTime,
			status: response.statusCode,
			body: body.length > 256 ? body.substr(0, 256) + '...' : body
		}
	};

	// production logs will automatically be JSON-parsed in Stackdriver
	console.log(JSON.stringify({
		type: 'REST API response JSON',
		payload: responseLog
	}));
};

/**
 * Login responses contain oauth info that should be applied to the response.
 * If `request.plugins.requestAuth.reply` exists (supplied by the requestAuthPlugin),
 * the application is able to set cookies on the response. Otherwise, return
 * the login response unchanged
 */
var parseLoginAuth = exports.parseLoginAuth = function parseLoginAuth(request, query) {
	return function (response) {
		if (query.type === 'login' && request.plugins.requestAuth && !response.value.error) {
			// kill the logged-out auth
			(0, _authUtils.removeAuthState)(['oauth_token', 'refresh_token'], request, request.plugins.requestAuth.reply);
			// only return the member, no oauth data
			return _extends({}, response, {
				value: { member: response.value.member }
			});
		}
		return response;
	};
};

/**
 * When a tough-cookie cookie jar is provided, forward the cookies along with
 * the overall /api response back to the client
 */
var injectResponseCookies = exports.injectResponseCookies = function injectResponseCookies(request) {
	return function (_ref16) {
		var _ref17 = _slicedToArray(_ref16, 3),
		    response = _ref17[0],
		    _ = _ref17[1],
		    jar = _ref17[2];

		if (!jar) {
			return;
		}
		var requestUrl = response.toJSON().request.uri.href;
		jar.getCookies(requestUrl).forEach(function (cookie) {
			var cookieOptions = {
				domain: cookie.domain,
				path: cookie.path,
				isHttpOnly: cookie.httpOnly,
				isSameSite: false,
				isSecure: process.env.NODE_ENV === 'production'
			};

			request.plugins.requestAuth.reply.state(cookie.key, (0, _stringUtils.cleanRawCookies)(cookie.value), cookieOptions);
		});
	};
};

/**
 * Make an API request and parse the response into the expected `response`
 * object shape
 */
var makeApiRequest$ = exports.makeApiRequest$ = function makeApiRequest$(request, API_TIMEOUT, duotoneUrls) {
	var setApiResponseDuotones = apiResponseDuotoneSetter(duotoneUrls);
	return function (_ref18) {
		var _ref19 = _slicedToArray(_ref18, 2),
		    requestOpts = _ref19[0],
		    query = _ref19[1];

		var request$ = query.mockResponse ? makeMockRequest(query.mockResponse) : makeExternalApiRequest(request, API_TIMEOUT);

		return _rxjs2.default.Observable.defer(function () {
			request.log(['api', 'info'], 'REST API request: ' + requestOpts.url);
			return request$(requestOpts).do(logApiResponse) // this will leak private info in API response
			.do(injectResponseCookies(request)).map(parseApiResponse(requestOpts.url)) // parse into plain object
			.catch(errorResponse$(requestOpts.url)).map(parseLoginAuth(request, query)) // login has oauth secrets - special case
			.map(apiResponseToQueryResponse(query)) // convert apiResponse to app-ready queryResponse
			.map(setApiResponseDuotones); // special duotone prop
		});
	};
};