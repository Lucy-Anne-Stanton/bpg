'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.cacheQueryEpic = exports.cacheSetEpic = exports.cacheClearEpic = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Provides a cache outside of Redux state that can optimistically update state
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * before an asynchronous API call returns
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * @module CacheMiddleware
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */


exports.checkEnable = checkEnable;

var _rxjs = require('rxjs');

var _rxjs2 = _interopRequireDefault(_rxjs);

var _reduxObservable = require('redux-observable');

var _cacheActionCreators = require('../actions/cacheActionCreators');

var _cacheUtils = require('../util/cacheUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function checkEnable() {
	if (typeof window !== 'undefined' && window.location) {
		var params = new URLSearchParams(window.location.search.slice(1));
		return !params.has('__nocache');
	}
	return true;
}

/**
 * Listen for any action that should clear cached state
 *
 * Note that this will clear the cache without emitting an action
 */
var cacheClearEpic = exports.cacheClearEpic = function cacheClearEpic(cache) {
	return function (action$) {
		return action$.ofType('CACHE_CLEAR').flatMap(function () {
			return cache.clear();
		}) // wait for cache to clear before continuing
		.ignoreElements();
	};
};

/**
 * Listen for any action that should set cached state with a
 * `{ queries, responses }` payload
 *
 * API_SUCCESS means there is fresh data ready to be stored - extract the
 * queries and their responses, then dispatch `CACHE_SET` actions with each
 * pair
 *
 * Not that this will set the cache without emitting an action
 */
var cacheSetEpic = exports.cacheSetEpic = function cacheSetEpic(cache) {
	return function (action$) {
		return action$.ofType('API_SUCCESS', 'CACHE_SET').flatMap(function (_ref) {
			var _ref$payload = _ref.payload,
			    queries = _ref$payload.queries,
			    responses = _ref$payload.responses;
			return _rxjs2.default.Observable.from(queries).zip(_rxjs2.default.Observable.from(responses));
		}).flatMap(function (_ref2) {
			var _ref3 = _slicedToArray(_ref2, 2),
			    query = _ref3[0],
			    response = _ref3[1];

			return (0, _cacheUtils.cacheWriter)(cache)(query, response);
		}).ignoreElements();
	};
};

/**
 * Listen for any action that should query the cache using a payload of queries
 *
 * Observables are heavily used in CACHE_REQUEST because each query results in
 * an async 'get' (Promise) from the Cache - all 'gets' happen in parallel and
 * the results are collated into a single response object containing the cache
 * hits.
 */
var cacheQueryEpic = exports.cacheQueryEpic = function cacheQueryEpic(cache) {
	return function (action$) {
		return action$.ofType('API_REQUEST').flatMap(function (_ref4) {
			var payload = _ref4.payload;
			return _rxjs2.default.Observable.from(payload) // fan out
			.flatMap((0, _cacheUtils.cacheReader)(cache)) // look for a cache hit
			.filter(function (_ref5) {
				var _ref6 = _slicedToArray(_ref5, 2),
				    query = _ref6[0],
				    response = _ref6[1];

				return response;
			}) // ignore misses
			.reduce(function (acc, _ref7) {
				var _ref8 = _slicedToArray(_ref7, 2),
				    query = _ref8[0],
				    response = _ref8[1];

				return { // fan-in to create response
					queries: [].concat(_toConsumableArray(acc.queries), [query]),
					responses: [].concat(_toConsumableArray(acc.responses), [response])
				};
			}, { queries: [], responses: [] }) // empty response structure
			.filter(function (cacheResponse) {
				return cacheResponse.responses.length;
			});
		}).map(_cacheActionCreators.cacheSuccess);
	};
};

var getCacheEpic = function getCacheEpic() {
	var cache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : (0, _cacheUtils.makeCache)();
	return checkEnable() ? (0, _reduxObservable.combineEpics)(cacheClearEpic(cache), cacheSetEpic(cache), cacheQueryEpic(cache)) : function (action$) {
		return action$.ignoreElements();
	};
};

exports.default = getCacheEpic;