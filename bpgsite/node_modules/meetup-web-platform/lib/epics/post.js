'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _rxjs = require('rxjs');

var _rxjs2 = _interopRequireDefault(_rxjs);

var _syncActionCreators = require('../actions/syncActionCreators');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * PostEpic provides a generic interface for triggering POST requests and
 * dispatching particular actions with the API response. The POST action must
 * follow this structure:
 *
 * ```
 * {
 *   type: 'POST_<SOMETHING>' (or '<SOMETHING>_POST'),
 *   payload: {
 *     query: a 'reactive query' object that maps to an API call,
 *     onSuccess: a callback that takes the API response as an argument, and
 *       returns an action object. The middleware takes care of dispatch
 *     onError: a callback that takes an Error argument and returns an action
 *       object
 *   }
 * }
 * ```
 *
 * This structure usually allows the success/error handling code to be bundled
 * alongside the POST action creator, with the expectation that all response
 * processing can be done there
 *
 * @module PostEpic
 */

/**
 * get a function that receives a post action and returns the corresponding
 * fetch Promise
 *
 * The wrapping function needs current app state in order to apply correct
 * config
 *
 * @param {Object} { apiUrl, csrf } from state.config
 * @param {Object} postAction, providing query, onSuccess, and onError
 * @return {Promise} results of the fetch, either onSuccess or onError
 */
var getPostQueryFetch = function getPostQueryFetch(fetchQueries, store) {
  return function (query) {
    var _store$getState = store.getState(),
        _store$getState$confi = _store$getState.config,
        apiUrl = _store$getState$confi.apiUrl,
        csrf = _store$getState$confi.csrf;

    return fetchQueries(apiUrl, { method: 'POST', csrf: csrf })([query]);
  };
};

/**
 * Make the POST call to the API and send the responses to the appropriate
 * places
 *
 * 1. Always send successful post responses to API_SUCCESS action
 * 2. If POST action has an 'onSuccess' action creators, send successful
 *    responses there as well
 * 3. Failed POST responses will be sent to the POST action's `onError`
 */
var doPost$ = function doPost$(fetchPostQuery) {
  return function (_ref) {
    var query = _ref.query,
        onSuccess = _ref.onSuccess,
        onError = _ref.onError;
    return _rxjs2.default.Observable.fromPromise(fetchPostQuery(query)) // make the fetch call
    .flatMap(function (responses) {
      return (
        // success! return API_SUCCESS and whatever the POST action wants to do onSuccess
        _rxjs2.default.Observable.of((0, _syncActionCreators.apiSuccess)(responses), onSuccess && onSuccess(responses))
      );
    }).catch(function (err) {
      return _rxjs2.default.Observable.of(onError(err));
    });
  };
};

var getPostEpic = function getPostEpic(fetchQueries) {
  return function (action$, store) {
    return action$.filter(function (_ref2) {
      var type = _ref2.type;
      return type.endsWith('_POST') || type.startsWith('POST_');
    }).map(function (_ref3) {
      var payload = _ref3.payload;
      return payload;
    }).flatMap(doPost$(getPostQueryFetch(fetchQueries, store)));
  };
};

exports.default = getPostEpic;