'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.oauthScheme = exports.getAuthenticate = exports.getRequestAuthorizer$ = exports.getAccessToken$ = exports.applyRequestAuthorizer$ = undefined;
exports.getAnonymousCode$ = getAnonymousCode$;
exports.default = register;

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _rxjs = require('rxjs');

var _rxjs2 = _interopRequireDefault(_rxjs);

var _fetchUtils = require('../util/fetchUtils');

var _authUtils = require('../util/authUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module requestAuthPlugin
 */

function verifyAuth(auth) {
	var keys = Object.keys(auth);
	if (!keys.length) {
		var errorMessage = 'No auth token(s) provided';
		console.error(_chalk2.default.red(errorMessage), ': application can not fetch data.', 'You might be able to recover by clearing cookies and refreshing');
		throw new Error(errorMessage);
	}
	return auth;
}

var handleLogout = function handleLogout(request) {
	request.log(['info', 'auth'], 'Logout received, clearing cookies to re-authenticate');
	return (0, _authUtils.removeAuthState)([(0, _authUtils.getMemberCookieName)(request), 'oauth_token', 'refresh_token'], request, request.plugins.requestAuth.reply);
};

function getAuthType(request) {
	var memberCookie = (0, _authUtils.getMemberCookieName)(request);
	var allowedAuthTypes = [memberCookie, 'oauth_token', '__internal_oauth_token'];
	// search for a request.state cookie name that matches an allowed auth type
	return allowedAuthTypes.reduce(function (authType, allowedType) {
		return authType || request.state[allowedType] && allowedType;
	}, null);
}

/**
 * Ensure that the passed-in Request contains a valid Oauth token
 *
 * If the Request already has a valid oauth token, it is returned unchanged,
 * otherwise the request is parsed for more info and a new token is set
 *
 * @param {Observable} requestAuthorizer$ a function that takes a request and emits new auth
 *   data
 * @param {Request} request Hapi request to modify with auth token (if necessary)
 * @return {Observable} Observable that emits the request with auth applied
 */
var applyRequestAuthorizer$ = exports.applyRequestAuthorizer$ = function applyRequestAuthorizer$(requestAuthorizer$) {
	return function (request) {
		// logout is accomplished exclusively through a `logout` querystring value
		if ('logout' in request.query) {
			handleLogout(request);
		}

		// always need oauth_token, even if it's an anonymous (pre-reg) token
		// This is 'deferred' because we don't want to start fetching the token
		// before we know that it's needed
		request.log(['info', 'auth'], 'Checking for oauth_token in request');
		var authType = getAuthType(request);

		if (authType) {
			request.log(['info', 'auth'], 'Request contains auth token (' + authType + ')');
			request.plugins.requestAuth.authType = authType;
			return _rxjs2.default.Observable.of(request);
		}

		request.log(['info', 'auth'], 'Request does not contain auth token');
		return requestAuthorizer$(request) // get anonymous oauth_token
		.do((0, _authUtils.applyAuthState)(request, request.plugins.requestAuth.reply)).map(function () {
			return request;
		});
	};
};

/**
 * Get an anonymous code from the API that can be used to generate an oauth
 * access token
 *
 * @param {Object} config { OAUTH_AUTH_URL, oauth }
 * @param {String} redirect_uri Return url after anonymous grant
 */
function getAnonymousCode$(_ref, redirect_uri) {
	var _ref$API_TIMEOUT = _ref.API_TIMEOUT,
	    API_TIMEOUT = _ref$API_TIMEOUT === undefined ? 5000 : _ref$API_TIMEOUT,
	    OAUTH_AUTH_URL = _ref.OAUTH_AUTH_URL,
	    oauth = _ref.oauth;

	if (!oauth.key) {
		throw new ReferenceError('OAuth consumer key is required');
	}

	var authParams = new URLSearchParams();
	authParams.append('response_type', 'anonymous_code');
	authParams.append('client_id', oauth.key);
	authParams.append('redirect_uri', redirect_uri);
	var authURL = OAUTH_AUTH_URL + '?' + authParams;
	var requestOpts = {
		method: 'GET',
		headers: {
			Accept: 'application/json'
		}
	};

	return _rxjs2.default.Observable.defer(function () {
		console.log('Fetching anonymous auth code from ' + OAUTH_AUTH_URL);
		return _rxjs2.default.Observable.fromPromise(fetch(authURL, requestOpts)).timeout(API_TIMEOUT).flatMap((0, _fetchUtils.tryJSON)(OAUTH_AUTH_URL)).map(function (_ref2) {
			var code = _ref2.code;
			return {
				grant_type: 'anonymous_code',
				token: code
			};
		});
	});
}

/**
 * Curry the config to generate a function that receives a grant type and grant
 * token that can be used to generate an oauth access token from the API
 * @param {Object} config object containing the oauth secret and key
 * @param {String} redirect_uri Return url after anonymous grant
 * @param {Object} headers Hapi request headers for anonymous user request
 * @return {Object} the JSON-parsed response from the authorize endpoint
 *   - contains 'access_token', 'refresh_token'
 */
var getAccessToken$ = exports.getAccessToken$ = function getAccessToken$(_ref3, redirect_uri) {
	var _ref3$API_TIMEOUT = _ref3.API_TIMEOUT,
	    API_TIMEOUT = _ref3$API_TIMEOUT === undefined ? 5000 : _ref3$API_TIMEOUT,
	    OAUTH_ACCESS_URL = _ref3.OAUTH_ACCESS_URL,
	    oauth = _ref3.oauth;

	if (!oauth.key) {
		throw new ReferenceError('OAuth consumer key is required');
	}
	if (!oauth.secret) {
		throw new ReferenceError('OAuth consumer secret is required');
	}
	var params = {
		client_id: oauth.key,
		client_secret: oauth.secret,
		redirect_uri: redirect_uri
	};
	return function (headers) {
		var requestOpts = {
			method: 'POST',
			headers: {
				Cookie: headers.cookie,
				Accept: headers.accept,
				'Accept-Language': headers['accept-language'],
				'Cache-Control': headers['cache-control']
			}
		};
		var accessParams = Object.keys(params).reduce(function (accessParams, key) {
			accessParams.append(key, params[key]);
			return accessParams;
		}, new URLSearchParams());

		return function (_ref4) {
			var grant_type = _ref4.grant_type,
			    token = _ref4.token;


			if (!token) {
				// programmer error or catastrophic auth failure - throw exception
				throw new ReferenceError('No grant token provided - cannot obtain access token');
			}

			accessParams.append('grant_type', grant_type);
			if (grant_type === 'anonymous_code') {
				console.log('Fetching anonymous access_token from ' + OAUTH_ACCESS_URL);
				accessParams.append('code', token);
			}
			if (grant_type === 'refresh_token') {
				console.log('Refreshing access_token from ' + OAUTH_ACCESS_URL);
				accessParams.append('refresh_token', token);
			}

			var url = OAUTH_ACCESS_URL + '?' + accessParams;

			return _rxjs2.default.Observable.fromPromise(fetch(url, requestOpts)).timeout(API_TIMEOUT).flatMap((0, _fetchUtils.tryJSON)(OAUTH_ACCESS_URL));
		};
	};
};

var refreshToken$ = function refreshToken$(refresh_token) {
	return _rxjs2.default.Observable.of({
		grant_type: 'refresh_token',
		token: refresh_token
	});
};

/**
 * Curry a function that will get a new auth token for a passed-in request.
 * For an anonymous auth, the request header information is used to determine
 * the location and language of the anonymous member
 *
 * @param {Object} config { OAUTH_AUTH_URL, OAUTH_ACCESS_URL, oauth }
 * @param {Object} request the Hapi request that needs to be authorized
 */
var getRequestAuthorizer$ = exports.getRequestAuthorizer$ = function getRequestAuthorizer$(config) {
	var redirect_uri = 'http://www.meetup.com/'; // required param set in oauth consumer config
	var anonymousCode$ = getAnonymousCode$(config, redirect_uri);
	var accessToken$ = getAccessToken$(config, redirect_uri);

	// if the request has a refresh_token, use it. Otherwise, get a new anonymous access token
	return function (_ref5) {
		var headers = _ref5.headers,
		    refresh_token = _ref5.state.refresh_token;
		return _rxjs2.default.Observable.if(function () {
			return refresh_token;
		}, refreshToken$(refresh_token), anonymousCode$).flatMap(accessToken$(headers)).do(verifyAuth);
	};
};

var getAuthenticate = exports.getAuthenticate = function getAuthenticate(authorizeRequest$) {
	return function (request, reply) {
		request.log(['info', 'auth'], 'Authenticating request');
		return authorizeRequest$(request).do(function (request) {
			request.log(['info', 'auth'], 'Request authenticated');
		}).subscribe(function (request) {
			var credentials = request.state[getAuthType(request)];
			reply.continue({ credentials: credentials, artifacts: credentials });
		}, function (err) {
			return reply(err, null, { credentials: null });
		});
	};
};

/**
 * Request authorizing scheme
 *
 * 1. assign a reference to the reply interface on request.plugins.requestAuth
 * 2. make sure the correct MEETUP_MEMBER[_DEV] cookie is used for auth
 * 3. return the authentication function from getAuthenticate, which ensures
 * that all requests have valid auth credentials (anonymous or logged in)
 *
 * https://hapijs.com/api#serverauthschemename-scheme
 * https://hapijs.com/api#serverauthstrategyname-scheme-mode-options
 *
 * @param {Object} server the Hapi app server instance
 * @param {Object} options the options passed to `server.auth.strategy`for the
 *   auth stategy instance
 */
var oauthScheme = exports.oauthScheme = function oauthScheme(server, options) {
	(0, _authUtils.configureAuthCookies)(server, options); // apply default config for auth cookies
	server.ext('onPreAuth', _authUtils.setPluginState); // provide a reference to `reply` on the request

	var authorizeRequest$ = applyRequestAuthorizer$(getRequestAuthorizer$(options));

	return {
		authenticate: getAuthenticate(authorizeRequest$)
	};
};
/**
 * This plugin does two things.
 *
 * 1. Adds an 'authorize' interface on the Hapi `request`, which ensures that
 * the request has an oauth_token cookie - it provides an anonymous token when
 * none is provided in the request, and refreshes a token that has expired
 * 2. Adds a new route that returns the auth JSON containing the new oauth_token
 * (configurable, defaults to '/auth')
 *
 * {@link http://hapijs.com/tutorials/plugins}
 */
function register(server, options, next) {
	server.auth.scheme('oauth', oauthScheme);
	next();
}
register.attributes = {
	name: 'requestAuth',
	version: '1.0.0'
};