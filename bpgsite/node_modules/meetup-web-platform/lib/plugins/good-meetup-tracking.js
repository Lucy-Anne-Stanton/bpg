'use strict';

// Load Modules

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var avro = require('avsc');
var Hoek = require('hoek');
var request = require('request');
var Stream = require('stream');

var internals = {
	defaults: {

		endpoint: 'http://log.analytics.mup-prod.mup.zone/log',
		// in prod, make a `request` call, otherwise no-op
		postData: process.env.NODE_ENV === 'production' ? request.post.bind(request) : function () {},
		// currently the schema is manually copied from
		// https://github.dev.meetup.com/meetup/meetup/blob/master/modules/base/src/main/versioned_avro/Activity_v3.avsc
		schema: avro.parse({
			namespace: 'com.meetup.base.avro',
			type: 'record',
			name: 'Activity',
			doc: 'v3',
			fields: [{ name: 'requestId', type: 'string' }, { name: 'timestamp', type: 'string' }, { name: 'url', type: 'string' }, { name: 'aggregratedUrl', type: 'string', default: '' }, // it's misspelled in the original spec
			{ name: 'ip', type: 'string', default: '' }, { name: 'agent', type: 'string', default: '' }, { name: 'memberId', type: 'int' }, { name: 'trackId', type: 'string' }, { name: 'mobileWeb', type: 'boolean' }, { name: 'platform', type: 'string' }, { name: 'referer', type: 'string' }, // it's misspelled in the original spec
			{ name: 'trax', type: { type: 'map', values: 'string' } }, {
				name: 'platformAgent',
				type: {
					type: 'enum',
					name: 'PlatformAgent',
					symbols: ['WEB', 'NATIVE', 'NATIVE_APP_WEB_VIEW', 'THIRD_PARTY_UNKNOWN', 'UNKNOWN']
				},
				default: 'UNKNOWN'
			}]
		})
	}
};

/**
 * A stream that transforms a Good event into an Avro buffer according to a
 * schema
 */

var GoodMeetupTracking = function (_Stream$Transform) {
	_inherits(GoodMeetupTracking, _Stream$Transform);

	/**
  * @param {Object} config the config options for a Stream.Transform
  * @return {undefined} side effects only
  */
	function GoodMeetupTracking(config) {
		_classCallCheck(this, GoodMeetupTracking);

		var _this = _possibleConstructorReturn(this, (GoodMeetupTracking.__proto__ || Object.getPrototypeOf(GoodMeetupTracking)).call(this, { objectMode: true }));

		config = config || {};
		_this._settings = Hoek.applyToDefaults(internals.defaults, config);
		return _this;
	}

	/**
  * @param {Error|null} err error returned from failed request
  * @param {http.IncomingMessage} response the response object
  * @param {String} body the body of the response
  * @return {undefined} side effects only
  */


	_createClass(GoodMeetupTracking, [{
		key: '_transform',


		/**
   * Receive event data and do something with it - package into avro buffer,
   * send it
   *
   * @param {Object} event a Good event object
   * @param {String|undefined} enc Not sure what this is used for - ignored
   * @param {Function} next the next transform in the chain of Stream.Transform
   * @return {Object} the output of calling the next transform in the chain
   */
		value: function _transform(event, enc, next) {
			// log the data to stdout for Stackdriver
			var eventData = JSON.parse(event.data);
			console.log(JSON.stringify({
				type: 'Tracking event log',
				payload: eventData
			}));

			var record = this._settings.schema.toBuffer(eventData);

			var eventDate = new Date(parseInt(eventData.timestamp, 10));
			var data = {
				name: 'Activity',
				record: record.toString('base64'),
				version: 3,
				schemaUrl: 'gs://meetup-logs/avro_schemas/Activity_v3.avsc',
				date: eventDate.toISOString().substr(0, 10) };

			var body = JSON.stringify(data);
			var headers = {
				'Content-Type': 'application/json'
			};

			// format data for avro
			this._settings.postData(this._settings.endpoint, { headers: headers, body: body }, GoodMeetupTracking.postDataCallback);

			return next(null, data);
		}
	}], [{
		key: 'postDataCallback',
		value: function postDataCallback(err, response, body) {
			if (err) {
				console.error(err);
				return;
			}
			if (response && response.statusCode !== 200) {
				console.error('Activity track logging error: ' + body);
			}
		}
	}]);

	return GoodMeetupTracking;
}(Stream.Transform);

module.exports = GoodMeetupTracking;