'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _rxjs = require('rxjs');

var _rxjs2 = _interopRequireDefault(_rxjs);

var _apiUtils = require('../util/apiUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * Given the current request and API server host, proxy the request to the API
 * and return the responses corresponding to the provided queries.
 *
 * This module plugs in to any system that provides a `request` object with:
 * - headers
 * - method ('get'/'post')
 * - query string parameters parsed as a plain object (for GET requests)
 * - payload/body (for POST requests)
 *
 * @module ApiProxy
 */

/**
 * This function transforms a single request to the application server into a
 * parallel array of requests to the API server, and then re-assembles the
 * API responses into an array of 'query responses' - i.e. API responses that
 * are formatted with properties from their corresponding query (ref, type).
 *
 * Most of the `options` for the `externalRequest` are shared for all the API
 * requests, so these are initialized in `parseRequest`. `buildRequestArgs`
 * then curries those into a function that can accept a `query` to write the
 * query-specific options.
 *
 * @param {Request} request Hapi request object
 * @param {Object} baseUrl API server base URL for all API requests
 * @return Array$ contains all API responses corresponding to the provided queries
 */
var apiProxy$ = function apiProxy$(_ref) {
  var _ref$API_TIMEOUT = _ref.API_TIMEOUT,
      API_TIMEOUT = _ref$API_TIMEOUT === undefined ? 8000 : _ref$API_TIMEOUT,
      _ref$baseUrl = _ref.baseUrl,
      baseUrl = _ref$baseUrl === undefined ? '' : _ref$baseUrl,
      _ref$duotoneUrls = _ref.duotoneUrls,
      duotoneUrls = _ref$duotoneUrls === undefined ? {} : _ref$duotoneUrls;


  return function (request) {
    var _Rx$Observable;

    request.log(['api', 'info'], 'Parsing api endpoint request');
    // 1. get the queries and the 'universal' `externalRequestOpts` from the request

    var _parseRequest = (0, _apiUtils.parseRequest)(request, baseUrl),
        queries = _parseRequest.queries,
        externalRequestOpts = _parseRequest.externalRequestOpts;

    // 2. curry a function that uses `externalRequestOpts` as a base from which
    // to build the query-specific API request options object


    var queryToRequestOpts = (0, _apiUtils.buildRequestArgs)(externalRequestOpts);

    request.log(['api', 'info'], JSON.stringify(queries));
    // 3. map the queries onto an array of api request observables
    var apiRequests$ = queries.map(queryToRequestOpts).map(function (opts, i) {
      return [opts, queries[i]];
    }) // zip the query back into the opts
    .map((0, _apiUtils.makeApiRequest$)(request, API_TIMEOUT, duotoneUrls));

    // 4. zip them together to send them parallel and return responses in order
    return (_Rx$Observable = _rxjs2.default.Observable).zip.apply(_Rx$Observable, _toConsumableArray(apiRequests$));
  };
};

exports.default = apiProxy$;