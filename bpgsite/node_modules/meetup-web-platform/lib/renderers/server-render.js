'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _rxjs = require('rxjs');

var _rxjs2 = _interopRequireDefault(_rxjs);

var _boom = require('boom');

var _boom2 = _interopRequireDefault(_boom);

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _server = require('react-dom/server');

var _server2 = _interopRequireDefault(_server);

var _RouterContext = require('react-router/lib/RouterContext');

var _RouterContext2 = _interopRequireDefault(_RouterContext);

var _history = require('history');

var _match = require('react-router/lib/match');

var _match2 = _interopRequireDefault(_match);

var _reactRedux = require('react-redux');

var _createStore = require('../util/createStore');

var _dom = require('../components/dom');

var _dom2 = _interopRequireDefault(_dom);

var _NotFound = require('../components/NotFound');

var _NotFound2 = _interopRequireDefault(_NotFound);

var _localizationUtils = require('../util/localizationUtils');

var _configActionCreators = require('../actions/configActionCreators');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Ensure global Intl for use with FormatJS
(0, _localizationUtils.polyfillNodeIntl)();

var DOCTYPE = '<!DOCTYPE html>';

/**
 * An async module that renders the full app markup for a particular URL/location
 * using [ReactDOMServer]{@link https://facebook.github.io/react/docs/top-level-api.html#reactdomserver}
 *
 * @module ServerRender
 */

function getHtml(baseUrl, assetPublicPath, clientFilename) {
	var initialState = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
	var appMarkup = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';

	var htmlMarkup = _server2.default.renderToString(_react2.default.createElement(_dom2.default, {
		baseUrl: baseUrl,
		assetPublicPath: assetPublicPath,
		clientFilename: clientFilename,
		initialState: initialState,
		appMarkup: appMarkup
	}));
	return '' + DOCTYPE + htmlMarkup;
}

/**
 * Using the current route information and Redux store, render the app to an
 * HTML string and server response code.
 *
 * There are three parts to the render:
 *
 * 1. `appMarkup`, which corresponds to the markup that will be rendered
 * on the client by React. This string is built before the full markup because
 * it sets the data needed by other parts of the DOM, such as `<head>`.
 * 2. `htmlMarkup`, which wraps `appMarkup` with the remaining DOM markup.
 * 3. `doctype`, which is just the doctype element that is a sibling of `<html>`
 *
 * @param {Object} renderProps
 * @param {ReduxStore} store the store containing the initial state of the app
 * @return {Object} the statusCode and result used by Hapi's `reply` API
 *   {@link http://hapijs.com/api#replyerr-result}
 */
var getRouterRenderer = function getRouterRenderer(store, baseUrl, clientFilename, assetPublicPath) {
	return function (_ref) {
		var _ref2 = _slicedToArray(_ref, 2),
		    redirectLocation = _ref2[0],
		    renderProps = _ref2[1];

		// pre-render the app-specific markup, this is the string of markup that will
		// be managed by React on the client.
		//
		// **IMPORTANT**: this string is built separately from `<Dom />` because it
		// initializes page-specific state that `<Dom />` needs to render, e.g.
		// `<head>` contents
		var initialState = store.getState();
		var appMarkup = void 0;
		var result = void 0;
		var statusCode = void 0;

		try {
			renderProps.router.history = (0, _history.useBasename)(function () {
				return renderProps.router.history;
			})({ basename: baseUrl });
			appMarkup = _server2.default.renderToString(_react2.default.createElement(
				_reactRedux.Provider,
				{ store: store },
				_react2.default.createElement(_RouterContext2.default, renderProps)
			));

			// all the data for the full `<html>` element has been initialized by the app
			// so go ahead and assemble the full response body
			result = getHtml(baseUrl, assetPublicPath, clientFilename, initialState, appMarkup);
			statusCode = _NotFound2.default.rewind() || // if NotFound is mounted, return 404
			renderProps.routes.pop().statusCode || 200;
		} catch (e) {
			// log the error stack here because Observable logs not great
			console.error(e.stack);
			if (process.env.NODE_ENV === 'production') {
				throw e;
			}

			var _require = require('redbox-react'),
			    RedBoxError = _require.RedBoxError;

			appMarkup = _server2.default.renderToString(_react2.default.createElement(RedBoxError, { error: e }));
			result = DOCTYPE + '<html><body>' + appMarkup + '</body></html>';
			statusCode = 500;
		}

		return {
			statusCode: statusCode,
			result: result
		};
	};
};

/**
 * dispatch the actions necessary to set up the initial state of the app
 *
 * @param {Store} store Redux store for this request
 * @param {Object} config that initializes app (auth tokens, e.g. oauth_token)
 */
var dispatchConfig = function dispatchConfig(store, _ref3) {
	var apiUrl = _ref3.apiUrl,
	    _ref3$log = _ref3.log,
	    log = _ref3$log === undefined ? console.log : _ref3$log;

	log(['app', 'info'], _chalk2.default.green('Configuring apiUrl: ' + apiUrl));
	store.dispatch((0, _configActionCreators.configureApiUrl)(apiUrl));
};

/**
 * Curry a function that takes a Hapi request and returns an observable
 * that will emit the rendered HTML
 *
 * The outer function takes app-specific information about the routes,
 * reducer, and optional additional middleware
 *
 * @param {Object} routes the React Router routes object
 * @param {Function} reducer the root Redux reducer for the app
 * @param {Function} middleware (optional) any app-specific middleware that
 *   should be applied to the store
 *
 * @return {Function}
 *
 * -- Returned Fn --
 * @param {Request} request The request to render - must already have an
 * `oauth_token` in `state`
 * @return {Observable}
 */
var makeRenderer = function makeRenderer(routes, reducer, clientFilename, assetPublicPath) {
	var middleware = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
	var baseUrl = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : '/';
	return function (request) {

		middleware = middleware || [];
		request.log(['info'], _chalk2.default.green('Rendering ' + request.url.href));
		var connection = request.connection,
		    headers = request.headers,
		    info = request.info,
		    log = request.log,
		    path = request.path;


		var appLocation = path.replace(baseUrl + '/', '/');
		// request protocol might be different from original request that hit proxy
		// we want to use the proxy's protocol
		var requestProtocol = headers['x-forwarded-proto'] || connection.info.protocol;
		var apiUrl = requestProtocol + '://' + info.host + '/mu_api';

		// create the store
		var initialState = {};
		var createStore = (0, _createStore.getServerCreateStore)(routes, middleware, request);
		var store = createStore(reducer, initialState);
		// load initial config
		dispatchConfig(store, { apiUrl: apiUrl, log: log.bind(request) });

		// render skeleton if requested - the store is ready
		if ('skeleton' in request.query) {
			return _rxjs2.default.Observable.of({
				result: getHtml(baseUrl, assetPublicPath, clientFilename, store.getState()),
				statusCode: 200
			});
		}

		// otherwise render using the API and React router
		var storeIsReady$ = _rxjs2.default.Observable.create(function (obs) {
			obs.next(store.getState());
			return store.subscribe(function () {
				return obs.next(store.getState());
			});
		}).first(function (state) {
			return state.preRenderChecklist.every(function (isReady) {
				return isReady;
			});
		}); // take the first ready state

		request.log(['app', 'info'], 'Finding route for path: \'' + appLocation + '\'');
		return _rxjs2.default.Observable.bindNodeCallback(_match2.default)({ location: appLocation, routes: routes }).do(function (_ref4) {
			var _ref5 = _slicedToArray(_ref4, 2),
			    redirectLocation = _ref5[0],
			    renderProps = _ref5[1];

			if (!redirectLocation && !renderProps) {
				throw _boom2.default.notFound();
			}
		}).do(function () {
			request.log(['app', 'info'], 'Found app route, dispatching RENDER');
		}).do(function (_ref6) {
			var _ref7 = _slicedToArray(_ref6, 2),
			    redirectLocation = _ref7[0],
			    renderProps = _ref7[1];

			return store.dispatch({
				type: '@@server/RENDER',
				payload: renderProps.location
			});
		}).flatMap(function (args) {
			return storeIsReady$.map(function () {
				return args;
			});
		}) // `sample` appears not to work - this is equivalent
		.map(getRouterRenderer(store, baseUrl, clientFilename, assetPublicPath));
	};
};

exports.default = makeRenderer;