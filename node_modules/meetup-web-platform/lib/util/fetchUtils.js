'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.mergeCookies = exports.tryJSON = exports.fetchQueries = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _cookie = require('cookie');

var _cookie2 = _interopRequireDefault(_cookie);

var _stringUtils = require('./stringUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A module for middleware that would like to make external calls through `fetch`
 * @module fetchUtils
 */

/**
 * Wrapper around `fetch` to send an array of queries to the server. It ensures
 * that the request will have the required Oauth access token and constructs
 * the `fetch` call arguments based on the request method
 * @param {String} apiUrl the general-purpose endpoint for API calls to the
 *   application server
 * @param {Object} options {
 *     method: "get", "post", "delete", or "patch",
 *   }
 * @return {Promise} resolves with a `{queries, responses}` object
 */
var fetchQueries = exports.fetchQueries = function fetchQueries(apiUrl, options) {
	return function (queries, meta) {
		options.method = options.method || 'GET';
		var method = options.method,
		    headers = options.headers;


		var isPost = method.toLowerCase() === 'post';
		var isDelete = method.toLowerCase() === 'delete';

		var params = new URLSearchParams();
		params.append('queries', JSON.stringify(queries));
		if (meta) {
			params.append('metadata', JSON.stringify(meta));
			if (meta.logout) {
				params.append('logout', true);
			}
		}
		var searchString = '?' + params;
		var fetchUrl = '' + apiUrl + (isPost ? '' : searchString);
		var fetchConfig = {
			method: method,
			headers: _extends({}, headers || {}, {
				'content-type': isPost ? 'application/x-www-form-urlencoded' : 'text/plain',
				'x-csrf-jwt': isPost || isDelete ? options.csrf : ''
			}),
			credentials: 'same-origin' // allow response to set-cookies
		};
		if (isPost) {
			// assume client side
			fetchConfig.body = params;
		}
		return fetch(fetchUrl, fetchConfig).then(function (queryResponse) {
			return queryResponse.json().then(function (_ref) {
				var responses = _ref.responses,
				    error = _ref.error,
				    message = _ref.message;

				if (error) {
					throw new Error(message); // treat like an API error
				}
				return {
					queries: queries,
					responses: responses || [],
					csrf: queryResponse.headers.get('x-csrf-jwt')
				};
			});
		});
	};
};

var tryJSON = exports.tryJSON = function tryJSON(reqUrl) {
	return function (response) {
		var status = response.status,
		    statusText = response.statusText;

		if (status >= 400) {
			// status always 200: bugzilla #52128
			return Promise.reject(new Error('Request to ' + reqUrl + ' responded with error code ' + status + ': ' + statusText));
		}
		return response.text().then(function (text) {
			return JSON.parse(text);
		});
	};
};

/**
 * @param {String} rawCookieHeader a 'cookie' header string
 * @param {Object} newCookies an object of name-value cookies to inject
 */
var mergeCookies = exports.mergeCookies = function mergeCookies(rawCookieHeader, newCookies) {
	// request.state has _parsed_ cookies, but we need to send raw cookies
	// _except_ when the incoming request has been back-populated with new 'raw' cookies
	var oldCookies = _cookie2.default.parse((0, _stringUtils.cleanRawCookies)(rawCookieHeader));
	var mergedCookies = _extends({}, oldCookies, newCookies);
	return Object.keys(mergedCookies).map(function (name) {
		return name + '=' + mergedCookies[name];
	}).join('; ');
};