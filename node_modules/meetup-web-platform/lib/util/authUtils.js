'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.getMemberCookieName = exports.setPluginState = exports.configureAuthCookies = exports.removeAuthState = exports.applyAuthState = exports.configureAuthState = undefined;
exports.validateSecret = validateSecret;

var _joi = require('joi');

var _joi2 = _interopRequireDefault(_joi);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module authUtils
 */

var YEAR_IN_MS = 1000 * 60 * 60 * 24 * 365;

/**
 * Transform auth info from the API into a configuration for the corresponding
 * cookies to write into the Hapi request/response
 *
 * @param {Object} auth { oauth_token || access_token, refresh_token, expires_in }
 * object from API/Auth endpoint
 */
var configureAuthState = exports.configureAuthState = function configureAuthState(auth) {
	return {
		oauth_token: {
			value: auth.oauth_token || auth.access_token || '',
			opts: {
				ttl: (auth.expires_in || 0) * 1000
			}
		},
		refresh_token: {
			value: auth.refresh_token,
			opts: {
				ttl: YEAR_IN_MS * 2
			}
		}
	};
};

/**
 * Both the incoming request and the outgoing response need to have an
 * 'authorized' state in order for the app to render correctly with data from
 * the API, so this function modifies the request and the reply
 *
 * @param request Hapi request
 * @param auth { oauth_token || access_token, expires_in (seconds), refresh_token }
 */
var applyAuthState = exports.applyAuthState = function applyAuthState(request, reply) {
	return function (auth) {
		// there are secret tokens in `auth`, be careful with logging
		var authState = configureAuthState(auth);
		var authCookies = Object.keys(authState);

		request.log(['auth', 'info'], 'Setting auth cookies: ' + JSON.stringify(authCookies));
		Object.keys(authState).forEach(function (name) {
			var cookieVal = authState[name];
			// apply to request
			request.state['__internal_' + name] = cookieVal.value; // this will only be used for generating internal requests
			// apply to response - note this special `request.authorize.reply` prop assigned onPreAuth
			reply.state(name, cookieVal.value, cookieVal.opts);
		});
		return request;
	};
};

var removeAuthState = exports.removeAuthState = function removeAuthState(names, request, reply) {
	names.forEach(function (name) {
		request.state[name] = null;
		reply.unstate(name);
	});
};

function validateSecret(secret) {
	var _Joi$validate = _joi2.default.validate(secret, _joi2.default.string().min(32).required()),
	    value = _Joi$validate.value,
	    error = _Joi$validate.error;

	if (error) {
		throw error;
	}
	return value;
}

/**
 * apply default cookie options for auth-related cookies
 */
var configureAuthCookies = exports.configureAuthCookies = function configureAuthCookies(server, options) {
	var password = validateSecret(options.COOKIE_ENCRYPT_SECRET);
	var authCookieOptions = {
		encoding: 'iron',
		password: password,
		isSecure: process.env.NODE_ENV === 'production',
		path: '/',
		isHttpOnly: true,
		clearInvalid: true
	};
	server.state('oauth_token', authCookieOptions);
	server.state('refresh_token', authCookieOptions);
};

var setPluginState = exports.setPluginState = function setPluginState(request, reply) {
	// Used for setting and unsetting state, not for replying to request
	request.plugins.requestAuth = {
		reply: reply
	};

	return reply.continue();
};

var getMemberCookieName = exports.getMemberCookieName = function getMemberCookieName(request) {
	return request.server.app.isDevConfig ? 'MEETUP_MEMBER_DEV' : 'MEETUP_MEMBER';
};