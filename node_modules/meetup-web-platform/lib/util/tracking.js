'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.logTrack = exports.trackSession = exports.trackLogin = exports.trackApi = exports.trackNav = exports.trackLogout = exports.updateTrackId = exports.updateMemberId = exports.newSessionId = exports.SESSION_ID_COOKIE = exports.TRACK_ID_COOKIE = exports.MEMBER_ID_COOKIE = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = decorateTrack;

var _uuid = require('uuid');

var _uuid2 = _interopRequireDefault(_uuid);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isProd = process.env.NODE_ENV === 'production';

var YEAR_IN_MS = 1000 * 60 * 60 * 24 * 365;
var COOKIE_OPTS = {
	encoding: 'none',
	path: '/',
	isHttpOnly: true,
	isSecure: isProd
};

var MEMBER_ID_COOKIE = exports.MEMBER_ID_COOKIE = isProd ? 'MEETUP_MEMBER' : 'MEETUP_MEMBER_DEV';
var TRACK_ID_COOKIE = exports.TRACK_ID_COOKIE = isProd ? 'TRACK_ID' : 'TRACK_ID_DEV';
var SESSION_ID_COOKIE = exports.SESSION_ID_COOKIE = isProd ? 'SESSION_ID' : 'SESSION_ID_DEV';

/**
 * @method newSessionId
 *
 * simple tracking id for the browser session
 *
 * @param {Object} hapi response object
 */
var newSessionId = exports.newSessionId = function newSessionId(response) {
	var sessionId = _uuid2.default.v4();
	response.state(SESSION_ID_COOKIE, sessionId, COOKIE_OPTS);
	return sessionId;
};

/**
 * getter/setter for memberId cookie: if memberId is not passed, the cookie
 * will be unset
 */
var updateMemberId = exports.updateMemberId = function updateMemberId(response, memberId) {
	if (!memberId) {
		response.unstate(MEMBER_ID_COOKIE);
		return response.request.state[MEMBER_ID_COOKIE];
	}
	response.state(MEMBER_ID_COOKIE, memberId, _extends({}, COOKIE_OPTS, {
		ttl: YEAR_IN_MS * 20
	}));
	return memberId;
};

/**
 * @method updateTrackId
 *
 * Initialize the trackId for member or anonymous user - the longest-living id
 * we can assigned to a user. Stays in place until login or logout, when it is
 * exchanged for a new trackId
 *
 *  - If the user has a tracking cookie already set, do nothing.
 *  - Otherwise, generate a new uuid and set a tracking cookie.
 *
 * @param {Object} hapi response object
 */
var updateTrackId = exports.updateTrackId = function updateTrackId(response, doRefresh) {
	var trackId = response.request.state[TRACK_ID_COOKIE];

	if (!trackId || doRefresh) {
		// Generate a new trackId cookie
		trackId = _uuid2.default.v4();
		response.state(TRACK_ID_COOKIE, trackId, _extends({}, COOKIE_OPTS, {
			ttl: YEAR_IN_MS * 20
		}));
	}
	return trackId;
};

var trackLogout = exports.trackLogout = function trackLogout(log) {
	return function (response) {
		return log(response, {
			description: 'logout',
			memberId: parseInt(updateMemberId(response), 10) || 0,
			trackIdFrom: response.request.state[TRACK_ID_COOKIE] || '',
			trackId: updateTrackId(response, true),
			sessionId: response.request.state[SESSION_ID_COOKIE],
			url: response.request.info.referrer | ''
		});
	};
};

var trackNav = exports.trackNav = function trackNav(log) {
	return function (response, queryResponses, url, referrer) {
		var apiRequests = queryResponses.map(function (qr) {
			var ref = Object.keys(qr)[0];

			var _qr$ref = _extends({}, qr[ref]),
			    meta = _qr$ref.meta;

			return {
				requestId: meta.requestId,
				endpoint: meta.endpoint
			};
		});
		return log(response, {
			description: 'nav',
			memberId: parseInt(response.request.state[MEMBER_ID_COOKIE], 10) || 0,
			trackId: response.request.state[TRACK_ID_COOKIE] || '',
			sessionId: response.request.state[SESSION_ID_COOKIE] || '',
			url: url || '',
			referer: referrer || '',
			apiRequests: apiRequests
		});
	};
};

var trackApi = exports.trackApi = function trackApi(log) {
	return function (response, queryResponses) {
		var metadata = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
		var url = metadata.url,
		    referrer = metadata.referrer,
		    method = metadata.method;

		if (method === 'get') {
			return trackNav(log)(response, queryResponses, url, referrer);
		}
		// special case - login requests need to be tracked
		var loginResponse = queryResponses.find(function (r) {
			return r.login;
		});
		if ((loginResponse && loginResponse.login.value || {}).member) {
			var memberId = JSON.stringify(loginResponse.login.value.member.id);
			trackLogin(log)(response, memberId);
		}
		if ('logout' in response.request.query) {
			trackLogout(log)(response);
		}
	};
};

var trackLogin = exports.trackLogin = function trackLogin(log) {
	return function (response, memberId) {
		return log(response, {
			description: 'login',
			memberId: parseInt(updateMemberId(response, memberId), 10) || 0,
			trackIdFrom: response.request.state[TRACK_ID_COOKIE] || '',
			trackId: updateTrackId(response, true),
			sessionId: response.request.state[SESSION_ID_COOKIE],
			url: response.request.info.referrer || ''
		});
	};
};

var trackSession = exports.trackSession = function trackSession(log) {
	return function (response) {
		if (response.request.state[SESSION_ID_COOKIE]) {
			// if there's already a session id, there's nothing to track
			return null;
		}
		return log(response, {
			description: 'session',
			memberId: parseInt(response.request.state[MEMBER_ID_COOKIE], 10) || 0,
			trackId: updateTrackId(response),
			sessionId: newSessionId(response),
			url: response.request.url.path
		});
	};
};

var logTrack = exports.logTrack = function logTrack(platformAgent) {
	return function (response, trackInfo) {
		var requestHeaders = response.request.headers;
		var eventDate = new Date();
		var record = _extends({
			timestamp: eventDate.getTime().toString(),
			requestId: _uuid2.default.v4(),
			ip: requestHeaders['remote-addr'] || '',
			agent: requestHeaders['user-agent'] || '',
			platform: 'meetup-web-platform',
			platformAgent: 'WEB', // TODO: set this more accurately, using allowed values from avro schema
			mobileWeb: false,
			referer: '', // misspelled to align with schema
			trax: {}
		}, trackInfo);

		response.request.log(['tracking'], JSON.stringify(record));
		return record;
	};
};

function decorateTrack(platformAgent) {
	var log = logTrack(platformAgent);
	var api = trackApi(log);
	var login = trackLogin(log);
	var logout = trackLogout(log);
	var session = trackSession(log);
	var trackers = {
		api: api,
		login: login,
		logout: logout,
		session: session
	};
	return function (response, trackType) {
		for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
			args[_key - 2] = arguments[_key];
		}

		return trackers[trackType].apply(trackers, [response].concat(args));
	};
}