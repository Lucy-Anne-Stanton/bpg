'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.getFetchQueriesEpic = exports.locationSyncEpic = exports.getNavEpic = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = getSyncEpic;

var _rxjs = require('rxjs');

var _history = require('history');

var _reduxObservable = require('redux-observable');

var _reactRouter = require('react-router');

var _reactRouterRedux = require('react-router-redux');

var _syncActionCreators = require('../actions/syncActionCreators');

var _routeUtils = require('../util/routeUtils');

/**
 * Navigation actions will provide the `location` as the payload, which this
 * epic will use to collect the current Reactive Queries associated with the
 * active routes.
 *
 * These queries will then be dispatched in the payload of `apiRequest`. Any
 * metadata about the navigation action can also be sent to the `apiRequest`
 * here.
 *
 * @param {Object} routes The application's React Router routes
 * @returns {Function} an Epic function that emits an API_REQUEST action
 */
var getNavEpic = exports.getNavEpic = function getNavEpic(routes) {
	var activeQueries$ = (0, _routeUtils.activeRouteQueries$)(routes);
	var currentLocation = {}; // keep track of current route so that apiRequest can get 'referrer'
	return function (action$, store) {
		return action$.ofType(_reactRouterRedux.LOCATION_CHANGE, '@@server/RENDER').flatMap(function (_ref) {
			var payload = _ref.payload;

			// inject request metadata from context, including `store.getState()`
			var requestMetadata = {
				referrer: currentLocation.pathname,
				logout: 'logout' in payload.query
			};

			var apiRequestActions$ = activeQueries$(payload) // find the queries for the location
			.map(function (queries) {
				return (0, _syncActionCreators.apiRequest)(queries, requestMetadata);
			}).do(function () {
				return currentLocation = payload;
			}); // update to new location

			// emit cache clear _only_ when logout requested
			var cacheClearAction$ = requestMetadata.logout ? _rxjs.Observable.of({ type: 'CACHE_CLEAR' }) : _rxjs.Observable.empty();

			return _rxjs.Observable.merge(cacheClearAction$, apiRequestActions$);
		});
	};
};

/**
 * Any action that should reload the API data should be handled here, e.g.
 * LOGIN_SUCCESS, which should force the app to reload in an 'authorized'
 * state
 *
 * Note: this action is only possible in the browser, not the server, so
 * `browserHistory` is safe to use here.
 */
var locationSyncEpic = exports.locationSyncEpic = function locationSyncEpic(action$, store) {
	return action$.ofType('LOGIN_SUCCESS').do(function () {
		var location = _extends({}, store.getState().routing.locationBeforeTransitions);
		delete location.query.logout;
		(0, _history.useBasename)(function () {
			return _reactRouter.browserHistory;
		})({
			basename: location.basename
		}).replace(location); // this will trigger a LOCATION_CHANGE
	}).ignoreElements();
};

/**
 * Listen for actions that provide queries to send to the api - mainly
 * API_REQUEST
 *
 * emits (API_SUCCESS || API_ERROR) then API_COMPLETE
 */
var getFetchQueriesEpic = exports.getFetchQueriesEpic = function getFetchQueriesEpic(fetchQueriesFn) {
	return function (action$, store) {
		return action$.ofType('API_REQUEST').flatMap(function (_ref2) {
			var payload = _ref2.payload,
			    meta = _ref2.meta;

			// set up the fetch call to the app server
			var _store$getState = store.getState(),
			    config = _store$getState.config;

			var fetch = fetchQueriesFn(config.apiUrl, { method: 'GET' });
			return _rxjs.Observable.fromPromise(fetch(payload, meta)) // call fetch
			.takeUntil(action$.ofType(_reactRouterRedux.LOCATION_CHANGE)) // cancel this fetch when nav happens
			.map(_syncActionCreators.apiSuccess) // dispatch apiSuccess with server response
			.flatMap(function (action) {
				return _rxjs.Observable.of(action, (0, _syncActionCreators.apiComplete)());
			}) // dispatch apiComplete after resolution
			.catch(function (err) {
				return _rxjs.Observable.of((0, _syncActionCreators.apiError)(err));
			}); // ... or apiError
		});
	};
};

function getSyncEpic(routes, fetchQueries) {
	return (0, _reduxObservable.combineEpics)(getNavEpic(routes), locationSyncEpic, getFetchQueriesEpic(fetchQueries));
}